# This script was written as a part of springer bookchapter titled 
# "Incorporating sequence-dependent DNA shape and dynamics into 
# transcriptome data analysis"
# 
# 
# This script uses DNA shape profiles generated by dna_shape_analysis.R for 
# modelling the data to develop a classifier between the set of TF regulated 
# promoters and the remaining parameters (others)
# 

library(reshape)
library(ggplot2)
library(tidyverse)
library(cluster)
library(factoextra)
library(gridExtra)
# library(monier)
library(randomForest)
library(reprtree)
# library(devtools)
# install_github("araastat/reprtree")


params<-c("Shear", "Stretch", "Stagger", "Buckle", "PropTw", "Opening", 
          "Shift", "Slide", "Rise", "Tilt", "Roll", "Twist","MGW")
num_datasets<-2
seq_length<-20
nuc_class<-c("A","C","G","T")
data_labels<-c("TF1","TF2")
shape_data_names<-data_labels
#shape data
TF1<-read.table("5bin_dna_shape_TF1",header=T)
TF2<-read.table("5bin_dna_shape_TF2",header=T)

#flatten and vectorize static shape data 
per_sequence_shape<-function(data,seq_length){
   third_pos<-seq(1,dim(data)[1],seq_length-4)
   per_seq_res<-lapply(1:length(third_pos), function(pos){
      one_seq_data<-data[third_pos[pos]:(third_pos[pos]+(seq_length-5)),1:13]
      df<-melt(one_seq_data)
      df[,2]
   })
}
#flatten and vectorize ensemble shape data 
per_sequence_ensemble<-function(data,seq_length){
   third_pos<-seq(1,dim(data)[1],seq_length-4)
   per_seq_res<-lapply(1:length(third_pos), function(pos){
      one_seq_data<-data[third_pos[pos]:(third_pos[pos]+(seq_length-5)),14:78]
      df<-melt(one_seq_data)
      df[,2]
   })
}
# row names
row_names_vec<-function(data,seq_length){
   third_pos<-seq(1,dim(data)[1],seq_length-4)
   per_seq_res<-lapply(1:length(third_pos), function(pos){
      one_seq_data<-data[third_pos[pos]:(third_pos[pos]+(seq_length-5)),1:13]
      strsplit(rownames(one_seq_data)[1],"_")[[1]][1]
   })
}
#static column names
col_n<-c()
for(i in 1:length(params)){
   for(j in 1:(seq_length-4)){
      a_coln<-paste(params[i],"pos",j,sep="_")
      col_n<-c(col_n,a_coln)
   }
}
#ensemble column names
col_n_ens<-c()
for(i in 1:length(params)){
   for(k in 1:5){ #5 bins
      for(j in 1:(seq_length-4)){
         a_coln<-paste(params[i],paste("bin",k,sep=""),"pos",j-8,sep="_")
         col_n_ens<-c(col_n_ens,a_coln)
      }
   }
}
#use the features data to make test and training datasets
make_test_train_sets<-function(data,train_set_size,label_column,labels){
   df_filtered<-data
   train_size <- train_set_size  # 70% for train, 30% for test
   set.seed(123)
   class_1_data <- subset(df_filtered, get(label_column) == labels[1])
   class_2_data <- subset(df_filtered, get(label_column) == labels[2])
   train_samples_class_1 <- sample(1:nrow(class_1_data),nrow(class_1_data) * train_size)
   train_samples_class_2 <- sample(1:nrow(class_2_data),nrow(class_2_data) * train_size)
   train_data <- rbind(
      class_1_data[train_samples_class_1, ],
      class_2_data[train_samples_class_2, ]
   )
   test_data <- rbind(
      class_1_data[-train_samples_class_1, ],
      class_2_data[-train_samples_class_2, ]
   )
   list(train_data,test_data)
}

# to extract shape parameter measures according to positional binning by a given window size
binning_pos_data_static<-function(data,name_string,window_size,par_col){
   # data is the df of shape profiles
   # name_string is the name to be given to shape profiles for plotting
   # window size is the size of window to take all values at those positions
   # in one bin for a boxplot
   # par_col is the conformational parameter column number
   binned_pos_data<-lapply(1:(seq_length-4),function(x){
      pos_id<-seq(x,dim(data)[1],seq_length-4)
      pos_data<-data[pos_id,par_col]
      pos_data<-cbind(rep(paste("pos",(x+2),sep=""),length(pos_data)),as.numeric(pos_data))
      pos_data
   })
   binned_pos_data<-do.call(rbind,binned_pos_data)
   binned_pos_data<-cbind(rep(paste(name_string),dim(binned_pos_data)[1]),binned_pos_data)
   colnames(binned_pos_data)<-c("data","position","value")
   binned_pos_data
}

#flatten the shape features
shape_features<-lapply(1:length(shape_data_names),function(df_id){
   data<-get(shape_data_names[df_id])
   data_per_seq<-per_sequence_shape(data,20)
   data_per_seq<-as.data.frame(do.call(rbind,data_per_seq))
   data_rows<-row_names_vec(data,20)
   colnames(data_per_seq)<-col_n
   rownames(data_per_seq)<-data_rows
   data_per_seq$id<-paste(data_labels[df_id],1:dim(data_per_seq)[1],sep="")
   data_per_seq$label<-rep(paste(data_labels[df_id]),dim(data_per_seq)[1])
   data_per_seq
})
static_data<-as.data.frame(do.call(rbind,shape_features))
write.table(static_data,"static_features")

#flatten the ensemble features
ens_features<-lapply(1:length(shape_data_names),function(df_id){
   data<-get(shape_data_names[df_id])
   data_per_seq<-per_sequence_ensemble(data,20)
   data_per_seq<-as.data.frame(do.call(rbind,data_per_seq))
   data_rows<-row_names_vec(data,20)
   colnames(data_per_seq)<-col_n_ens
   rownames(data_per_seq)<-data_rows
   data_per_seq$id<-paste(data_labels[df_id],1:dim(data_per_seq)[1],sep="")
   data_per_seq$label<-rep(paste(data_labels[df_id]),dim(data_per_seq)[1])
   data_per_seq
})
ens_data<-as.data.frame(do.call(rbind,ens_features))
write.table(ens_data,"ensemble_features")

static_data<-read.table("static_features",header=T)
ens_data<-read.table("ensemble_features",header=T)

# MODELLING OF DATA FOR SEQUENCE, STATIC and ENSEMBLE 
set.seed(1234)
shape_test_train<-make_test_train_sets(static_data[,-which(names(static_data)=="id")],
                                       0.7,"label",c("TF1","TF2"))
ens_test_train<-make_test_train_sets(ens_data[,-which(names(ens_data)=="id")],
                                     0.7,"label",c("TF1","TF2"))

shape_train<-shape_test_train[[1]]
shape_test<-shape_test_train[[2]]
ens_train<-ens_test_train[[1]]
ens_test<-ens_test_train[[2]]

#RANDOM FOREST MODEL (SHAPE)
model_shape<-rpart(as.factor(label) ~ ., data = shape_train)
predicted_shape <- predict(model_shape, 
                              newdata = shape_test[,-which(names(shape_test) == "label")],
                              type="class")
pdf("tree_avg.pdf")
rpart.plot(model_shape)
dev.off()
# rpart.plot(rf_model_shape)
accuracy_shape <- sum(predicted_shape == shape_test[,which(names(shape_test) == "label")])*100/dim(shape_test)[1] 
cat("Accuracy of the Random Forest model:", accuracy_shape, "%\n")

#RANDOM FOREST MODEL (ensemble)
model_ens<-rpart(as.factor(label) ~ ., data = ens_train)
predicted_ens <- predict(model_ens, 
                            newdata = ens_test[,-which(names(ens_test) == "label")],
                            type="class")
# reprtree:::plot.getTree(rf_model_ens)
pdf("tree_ens.pdf")
rpart.plot(model_ens)
dev.off()
accuracy_ens <- sum(predicted_ens == ens_test[,which(names(ens_test) == "label")]) * 100/dim(ens_test)[1] 
cat("Accuracy of the Random Forest model:", accuracy_ens, "%\n")


